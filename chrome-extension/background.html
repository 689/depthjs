<html><head>
<script src="jquery-1.4.4.min.js"></script>
<script src="underscore-min.js"></script>

<script>
/*
DepthJS
Copyright (C) 2010 Aaron Zinman, Doug Fritz, Roy Shilkrot, and Greg Elliott

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


console.log('background.html Starting DepthJS');
var DepthJS = {
  __VERSION__: '0.1',
  backend: {},
  eventHandlers: {},
  cv: {},
  tools: {},
  portsByTabId: {},
  imageListeners: [],
  eventListeners: [],
  depthListeners: []
};

console.log('Making loader');

var WS_CONNECTING = 0;
var WS_OPEN = 1;
var WS_CLOSING = 2;
var WS_CLOSED = 3;

DepthJS.registerPopup = function(popupWindow) {
  console.log("LKASDJlkasdjflksajdflkasjdflkjasdflkjasdlkfjsalkdjlsakjdflasjdflksja");
  console.log(popupWindow);

  $(".disabled", popupWindow).live("click", function() {
    // Do nothing
  });

  $(".enabled", popupWindow).live("click", function(e) {
    console.log(e);
  });
};

DepthJS.init = function () {
  console.log("Connecting WebSocket");
  if (!DepthJS.backend.connect()) {
    console.log("Couldn't connect... aborting");
    return;
  }

  // Private collections
  var tab_cache = {};
  var window_cache = {};
  var focused_window_id;

  // Go through all existing tabs/windows and add to cache
  chrome.windows.getAll({populate: true}, function(windows) {
    for (var i = 0; i < windows.length; ++i) {
      var window = windows[i];
      if (window.focused == true) {
        focused_window = window.id;
      }

      console.log('Adding existing window '+ obj_repr(window, 'Window'));
      for (var j = 0; j < window.tabs.length; ++j) {
        var tab = window.tabs[j];
        tab.windowId = window.id;
        console.log('Adding existing tab ' + obj_repr(tab, 'Tab'));
        tab_cache[tab.id] = tab;

        if (tab.status == 'complete') {
          // We should add this already loaded tab
          DepthJS.eventHandlers.onNewTab(tab.url, tab.title, window.id, tab.id);
        }
      }
      delete window.tabs; // Unnecessary... it'll be too stale to do anything with.
      window_cache[window.id] = window;
    }
  });

  // Subscribe to event handlers
  var obj_repr = DepthJS.tools.obj_repr;
  chrome.tabs.onCreated.addListener(function(tab) {
    // console.log('new tab created: ' + obj_repr(tab, 'Tab'));
    tab_cache[tab.id] = tab;
  });

  chrome.tabs.onAttached.addListener(function(tabId, attachInfo) {
    // console.log('tab attached: id=' + tabId + ', attachInfo=' + obj_repr(attachInfo));
  });

  chrome.tabs.onDetached.addListener(function(tabId, detachInfo) {
    // console.log('tab detached: id=' + tabId + ', detachInfo=' + obj_repr(detachInfo));
  });

  chrome.tabs.onMoved.addListener(function(tabId, moveInfo) {
    // console.log('tab moved: id=' + tabId + ', moveInfo=' + obj_repr(moveInfo));
  });

  chrome.tabs.onRemoved.addListener(function(tabId) {
    // console.log('tab removed: id=' + tabId);
    // Close page
    var cachedTab = tab_cache[tabId];
    if (!cachedTab) {
      console.log('Could not find tabId ' + tabId + ' in cache: ' + cachedTab);
      return;
    }
    DepthJS.eventHandlers.onClosedTab(cachedTab.url, cachedTab.windowId, cachedTab.id);
    delete tab_cache[tabId];
  });

  chrome.tabs.onSelectionChanged.addListener(function(tabId, selectInfo) {
    // console.log('tab selection changed: id=' + tabId + ', selectInfo=' + obj_repr(selectInfo));
  });


  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    var cachedTab = tab_cache[tabId];
    if (!cachedTab) {
      console.log('Could not find tabId ' + tabId + ' in cache: ' + cachedTab);
      return;
    }

    if (changeInfo.status == 'complete' && cachedTab.status == 'loading') {
      console.log('tab loaded: changeInfo=' + obj_repr(changeInfo) +
                  ", tab=" + obj_repr(tab, 'Tab') +
                  ", tabInCache=" + obj_repr(tab_cache[tab.id], 'Tab'));
      DepthJS.eventHandlers.onNewTab(tab.url, tab.title, tab.windowId, tab.id);
    } else if (tab.url != cachedTab.url) {
      console.log('URL CHANGED IN onUpdated: changeInfo=' + obj_repr(changeInfo) +
                  ", tab=" + obj_repr(tab, 'Tab') +
                  ", tabInCache=" + obj_repr(tab_cache[tab.id], 'Tab'));
      DepthJS.eventHandlers.onClosedTab(cachedTab.url, cachedTab.windowId, cachedTab.id);
      if (tab.status == 'complete') {
        // Never the case?
        DepthJS.eventHandlers.onNewTab(tab.url, tab.title, tab.windowId, tab.id);
      }
    }
    // Save state
    delete tab_cache[tabId]; // help GC
    tab_cache[tabId] = tab;
  });

  chrome.windows.onCreated.addListener(function(window) {
    // console.log('new window created: ' + obj_repr(window, 'Window'));
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    // console.log('window focus changed: id=' + windowId);
  });

  chrome.windows.onRemoved.addListener(function(windowId) {
    // console.log('window removed: id=' + windowId);
  });

  chrome.browserAction.onClicked.addListener(function(tab) {
    // console.log('broswerAction clicked');
  });

};

DepthJS.tools.obj_repr = function (obj, className) {
  var buf = [];
  if (className === undefined) {
    buf.push('[Object ');
  } else {
    buf.push('[' + className + ' ');
  }
  for (var key in obj) {
    buf.push(key + '=' + obj[key]);
    buf.push(', ');
  }
  buf.pop();
  buf.push(']');
  return buf.join('');
};

DepthJS.backend.eventWs = null;
DepthJS.backend.imageWs = null;
DepthJS.backend.depthWs = null;
DepthJS.backend.host = "localhost";
DepthJS.backend.port = 8000;
DepthJS.backend.connecting = false;
DepthJS.backend.connected = false;

DepthJS.backend.connect = function() {
  DepthJS.backend.connecting = true;
  chrome.extension.sendRequest({action: "connecting"});
  var connected = 0;
  function check() {
    connected++;
    if (connected == 3) {
      console.log("All 3 connected");
      chrome.extension.sendRequest({action: "connected"});
      DepthJS.backend.connecting = false;
      DepthJS.backend.connected = true;
    }
  }

  // If we do not connect within a timeout period,
  // effectively cancel it and let the popup know.
  setTimeout(function() {
    if (connected != 3) {
      DepthJS.backend.disconnect();
    }
  }, 3000);

  return _.all(_.map(["event", "image", "depth"], function(stream) {
    var path = "ws://" + DepthJS.backend.host + ":" + DepthJS.backend.port + "/" + stream;
    console.log("Connecting to " + stream + " stream on " + path);

    // Clear out any old sockets
    var oldSocket = DepthJS.backend[stream+"Ws"];
    if (oldSocket != null) {
      oldSocket.onmessage = null;
      oldSocket.onclose = null;
      oldSocket.onopen = null;

      if (oldSocket.readyState == WS_OPEN ||
          oldSocket.readyState == WS_CONNECTING) {
        oldSocket.close();
      }
    }

    var socket = new WebSocket(path);
    DepthJS.backend[stream+"Ws"] = socket;

    socket.onmessage = function(data){
      DepthJS.backend.onMessage(stream, data);
    };

    socket.onclose = function() {
      DepthJS.backend.onDisconnect(stream);
    };

    socket.onopen = function() {
      DepthJS.backend.onConnect(stream);
      check();
    };

    return true;
  }));
};

DepthJS.backend.onMessage = function (stream, data) {
  if (stream == "event") {
    if (data === undefined || data.data == null) {
      return;
    }
    console.log(data.data);
    var msg = JSON.parse(data.data);
    if (!$.isPlainObject(msg)) {
      console.log('Unknown message: ' + data);
      return;
    }
    var handler = DepthJS.eventHandlers["on"+msg.type];
    if (handler != null) {
      handler(msg.data);
    }

    msg.jsonRep = data.data;
    // Don't send to all--send to only the current tab.
    // _.each(DepthJS.eventListeners, function(port) {
    //   port.postMessage(msg);
    // });
    chrome.tabs.getSelected(null, function (tab) {
      var tabId = tab.id;
      var tabPorts = DepthJS.portsByTabId[tabId];
      if (tabPorts == null) {
        console.log("Could not find ports for tabId " + tabId);
        return;
      }
      var eventPort = tabPorts.event;
      if (eventPort == null) {
        console.log("Could not find event port for tabId " + tabId);
        return;
      }

      eventPort.postMessage(msg);
    });
  } else if (stream == "image") {
    DepthJS.eventHandlers.onImageMsg(data);
  } else if (stream == "depth") {
    DepthJS.eventHandlers.onDepthMsg(data);
  }
};

DepthJS.backend.disconnect = function() {
  DepthJS.backend.connected = false;
  console.log("Disconnecting");
  chrome.extension.sendRequest({action: "disconnected"});
  return _.map(["event", "image", "depth"], function(stream) {
    var oldSocket = DepthJS.backend[stream+"Ws"];
    if (oldSocket != null) {
      oldSocket.onmessage = null;
      oldSocket.onclose = null;
      oldSocket.onopen = null;

      if (oldSocket.readyState == WS_OPEN ||
          oldSocket.readyState == WS_CONNECTING) {
        oldSocket.close();
      }
    }
    DepthJS.backend[stream+"Ws"] = null;
  });
}

DepthJS.backend.onDisconnect = function (stream) {
  console.log("Disconnected on " + stream + " stream");
  // If one is closed, close them all.
  DepthJS.backend.disconnect();
};

DepthJS.backend.onConnect = function (stream) {
  console.log("Connect on " + stream + " stream");
};

DepthJS.eventHandlers.onNewTab = function(url, title, windowId, tabId) {
};

DepthJS.eventHandlers.onClosedTab = function(url, windowId, tabId) {
  if (DepthJS.portsByTabId[tabId] != null) {
    console.log("Had ports by closed tab laying around, deleting");
    delete DepthJS.portsByTabId[tabId];
  }
};

DepthJS.eventHandlers.onReaccessedTab = function(url, windowId, tabId) {
};

(function() {
  // WebSockets have frames of a limited size (<32k seems to work best)
  // Buffer the data until we have a complete frame
  function makeImageBuffer(listeners, bytes) {
    var w = 640;
    var h = 480;
    var dataArray = [];
    var dataLength = 0;
    var frameSize = w*h*bytes;
    return function(frameEvent) {
      var frameData = atob(frameEvent.data);
      if (dataLength + frameData.length < frameSize) {
        dataArray.push(frameData);
        dataLength += frameData.length;
        console.log("got " + frameData.length + " bytes, need " + (frameSize - dataLength) + "more");
      } else {
        var rem = (dataLength + frameData.length) - frameSize;
        var dataTail = frameData.substring(0,frameData.length - rem);
        var remData = frameData.substring(frameData.length - rem + 1);
        dataArray.push(dataTail);
        var data = dataArray.join("");
        _.each(listeners, function(port) {
            console.log("sending image or depth data");
            port.postMessage({data: data});
        });
        dataArray = [];
        dataLength = 0;
        if (remData.length > 0) {
          dataArray.push(remData);
          dataLength += remData.length;
        }
      }
    };
  }
  DepthJS.eventHandlers.onDepthMsg = makeImageBuffer(DepthJS.depthListeners, 1);
  DepthJS.eventHandlers.onImageMsg = makeImageBuffer(DepthJS.imageListeners, 3);
})();

console.log('Defined DepthJS... launching init');
DepthJS.init();

console.log("Setting up message passing listener");
var urls = [];
chrome.extension.onConnect.addListener(function(port) {
  var name = port.name;
  console.assert(name == "event" || name == "image" || name == "depth");
  console.log(name + " port connected");
  var listeners =  DepthJS[name + "Listeners"];
  listeners.push(port);

  var tabId = port.sender.tab.id;
  var tabPorts = DepthJS.portsByTabId[tabId];
  if (tabPorts == null) {
    tabPorts = {}; DepthJS.portsByTabId[tabId] = tabPorts;
  }
  tabPorts[name] = port;


  if (name == "event") {
    port.onMessage.addListener(function (req) {
      if (req.type == "getThumbnailUrls") {
        chrome.windows.getAll({populate: true}, function(windows) {
          var finishedWindows = 0;
          _.each(windows, function(window) {
            console.log("Capturing windowId" + window.id);
            console.log(window);
            chrome.tabs.captureVisibleTab(window.id, null, function(dataUrl) {
              if (dataUrl !== undefined && dataUrl != null) {
                window.dataUrl = dataUrl;
              } else {
                console.log("Ignoring window " + window.id + " without dataUrl");
                // Because windows is closured in this function
                for (var i = 0; i < windows.length; ++i) {
                  if (windows[i].id == window.id) {
                    windows.splice(i, 1);
                    break;
                  }
                }
              }
              finishedWindows++;
              if (finishedWindows == windows.length) {
                console.log(["All thumbnails taken", windows]);
                port.postMessage({type: "ThumbnailUrls", data:{windows:windows}});
              }
            });
          });
        });
      }
    });
  }

  port.onDisconnect.addListener(function (e) {
    console.log(name + " port disconnected on tab " + tabId);
    DepthJS[name + "Listeners"] = _.reject(
      listeners, function(el) { el === port; });
    var _tabPorts = DepthJS.portsByTabId[tabId];
    if (_tabPorts) {
      delete _tabPorts[name];
      if (_.isEmpty(_tabPorts)) {
        console.log("for all ports on this tab");
        delete DepthJS.portsByTabId[tabId];
      }
    }
  });
});

function split(str, size) {
  var splits = [];
  var lastEnd = 0;
  while (true) {
    if (lastEnd + size > str.length) {
      if (lastEnd != str.length) splits.push(str.slice(lastEnd));
      break;
    } else {
      splits.push(str.slice(lastEnd, lastEnd+size));
      lastEnd += size;
    }
  }
  return splits;
}

chrome.extension.onRequest.addListener(function(req, sender, sendResponse) {
  if (req.action == "connect") {
    DepthJS.backend.connect();
  } else if (req.action == "disconnect") {
    DepthJS.backend.disconnect();
  } else if (req.action == "getConnectState") {
    if (DepthJS.backend.connecting) {
      sendResponse({state: "connecting"});
    } else {
      sendResponse({state: DepthJS.backend.connected ? "connected" : "disconnected"});
    }
  } else if (req.action == "depthoseTest") {
    console.log("depthosetest");
    test(makeTestDepthoseEvents());
  } else if (req.action == "pannerTest") {
    test(makeTestPannerEvents());
  } else if (req.action == "selectorBoxTest") {
    test(makeTestSelectorBoxEvents());
  }
});


function sendTestEvent(msg, callback) {
  console.log("Sending out test event " + msg.type);
  msg.jsonRep = JSON.stringify(msg);

  chrome.tabs.getSelected(null, function (tab) {
    console.assert(msg.type != undefined);
    if (tab == null) {
      console.log("tab got closed");
      return;
    }
    var tabId = tab.id;
    var tabPorts = DepthJS.portsByTabId[tabId];
    if (tabPorts == null) {
      console.log("Could not find ports for tabId " + tabId);
      return;
    }
    var eventPort = tabPorts.event;
    if (eventPort == null) {
      console.log("Could not find event port for tabId " + tabId);
      return;
    }
    console.log([msg, " send to ", eventPort]);
    eventPort.postMessage(msg);
    callback();
  });
}

function makeTestDepthoseEvents() {
  return [
    // {type:"Register", data:{}},
    // {type:"Pull", data:{}},
    // {type:"Move", data:{x: 15, y: 15}},
    // {type:"Unregister", data:{}},
    {type:"Register", data:{}},
    // {type:"Pull", data:{}},
    // {type:"Move", data:{x: -15, y: 15}},
    // {type:"Move", data:{x: 40, y: 80}},
    // {type:"Push", data:{}}
  ].reverse();
}

function makeTestPannerEvents() {
  return [
    {type:"Register", data:{}},
    {type:"HandOpen", data:{}},
    {type:"Move", data:{x: 10, y: 30}},
    {type:"Move", data:{x: 40, y: 50}},
    {type:"Unregister", data:{}},
  ].reverse();
}

function makeTestSelectorBoxEvents() {
  return [
     {type:"Register", data:{}},
     {type:"Move", data:{x: 50, y: 50}},
     {type:"Push", data:{}},
     {type:"Move", data:{x: 60, y: 0}},
     {type:"Move", data:{x: 60, y: 15}},
     {type:"Move", data:{x: 60, y: 25}},
     {type:"Move", data:{x: 60, y: 35}},
     {type:"Move", data:{x: 60, y: 45}},
     {type:"Move", data:{x: 60, y: 55}},
     {type:"Move", data:{x: 60, y: 65}},
     {type:"Move", data:{x: 60, y: 75}},
     {type:"Move", data:{x: 60, y: 85}},
     {type:"Move", data:{x: 60, y: 95}},
     {type:"Move", data:{x: 60, y: 100}},
     {type: "SwipeLeft", data: {}},
     {type:"Unregister", data:{}},
   ].reverse();
}

var currentTest = [];

function test(testEvents) {
  console.log("Starting new test sequence");
  // Cancel all other ones
  for (var i = 0; i < 20; i++) { currentTest.pop(); }
  // Make new test with closure
  var local = currentTest = testEvents;
  function next() {
    var event = local.pop();
    if (event != undefined) {
      sendTestEvent(event, function() {
        setTimeout(next, 1000);
      });
    }
  }
  next();
}

</script>
</head></html>
