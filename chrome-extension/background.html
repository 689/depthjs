<html><head>
<script src="jquery-1.4.4.min.js"></script>
<script src="socket.io.js"></script>
<script src="underscore-min.js"></script>

<script>
/*
DepthJS
Copyright (C) 2010 Aaron Zinman, Doug Fritz, Roy Shilkrot

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


console.log('background.html Starting DepthJS');
var DepthJS = {
  __VERSION__: '0.1',
  backend: {},
  eventHandlers: {},
  cv: {},
  tools: {},
  portsByTabId: {},
  imageListeners: [],
  eventListeners: [],
  depthListeners: []
};

console.log('Making loader');


DepthJS.init = function () {
  console.log("Connecting WebSocket");
  if (!DepthJS.backend.connect()) {
    console.log("Couldn't connect... aborting");
    return;
  }

  // Private collections
  var tab_cache = {};
  var window_cache = {};
  var focused_window_id;

  // Go through all existing tabs/windows and add to cache
  chrome.windows.getAll({populate: true}, function(windows) {
    for (var i = 0; i < windows.length; ++i) {
      var window = windows[i];
      if (window.focused == true) {
        focused_window = window.id;
      }

      console.log('Adding existing window '+ obj_repr(window, 'Window'));
      for (var j = 0; j < window.tabs.length; ++j) {
        var tab = window.tabs[j];
        tab.windowId = window.id;
        console.log('Adding existing tab ' + obj_repr(tab, 'Tab'));
        tab_cache[tab.id] = tab;

        if (tab.status == 'complete') {
          // We should add this already loaded tab
          DepthJS.eventHandlers.onNewTab(tab.url, tab.title, window.id, tab.id);
        }
      }
      delete window.tabs; // Unnecessary... it'll be too stale to do anything with.
      window_cache[window.id] = window;
    }
  });

  // Subscribe to event handlers
  var obj_repr = DepthJS.tools.obj_repr;
  chrome.tabs.onCreated.addListener(function(tab) {
    // console.log('new tab created: ' + obj_repr(tab, 'Tab'));
    tab_cache[tab.id] = tab;
  });

  chrome.tabs.onAttached.addListener(function(tabId, attachInfo) {
    // console.log('tab attached: id=' + tabId + ', attachInfo=' + obj_repr(attachInfo));
  });

  chrome.tabs.onDetached.addListener(function(tabId, detachInfo) {
    // console.log('tab detached: id=' + tabId + ', detachInfo=' + obj_repr(detachInfo));
  });

  chrome.tabs.onMoved.addListener(function(tabId, moveInfo) {
    // console.log('tab moved: id=' + tabId + ', moveInfo=' + obj_repr(moveInfo));
  });

  chrome.tabs.onRemoved.addListener(function(tabId) {
    // console.log('tab removed: id=' + tabId);
    // Close page
    var cachedTab = tab_cache[tabId];
    if (!cachedTab) {
      console.log('Could not find tabId ' + tabId + ' in cache: ' + cachedTab);
      return;
    }
    DepthJS.eventHandlers.onClosedTab(cachedTab.url, cachedTab.windowId, cachedTab.id);
    delete tab_cache[tabId];
  });

  chrome.tabs.onSelectionChanged.addListener(function(tabId, selectInfo) {
    // console.log('tab selection changed: id=' + tabId + ', selectInfo=' + obj_repr(selectInfo));
  });


  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    var cachedTab = tab_cache[tabId];
    if (!cachedTab) {
      console.log('Could not find tabId ' + tabId + ' in cache: ' + cachedTab);
      return;
    }

    if (changeInfo.status == 'complete' && cachedTab.status == 'loading') {
      console.log('tab loaded: changeInfo=' + obj_repr(changeInfo) +
                  ", tab=" + obj_repr(tab, 'Tab') +
                  ", tabInCache=" + obj_repr(tab_cache[tab.id], 'Tab'));
      DepthJS.eventHandlers.onNewTab(tab.url, tab.title, tab.windowId, tab.id);
    } else if (tab.url != cachedTab.url) {
      console.log('URL CHANGED IN onUpdated: changeInfo=' + obj_repr(changeInfo) +
                  ", tab=" + obj_repr(tab, 'Tab') +
                  ", tabInCache=" + obj_repr(tab_cache[tab.id], 'Tab'));
      DepthJS.eventHandlers.onClosedTab(cachedTab.url, cachedTab.windowId, cachedTab.id);
      if (tab.status == 'complete') {
        // Never the case?
        DepthJS.eventHandlers.onNewTab(tab.url, tab.title, tab.windowId, tab.id);
      }
    }
    // Save state
    delete tab_cache[tabId]; // help GC
    tab_cache[tabId] = tab;
  });

  chrome.windows.onCreated.addListener(function(window) {
    // console.log('new window created: ' + obj_repr(window, 'Window'));
  });

  chrome.windows.onFocusChanged.addListener(function(windowId) {
    // console.log('window focus changed: id=' + windowId);
  });

  chrome.windows.onRemoved.addListener(function(windowId) {
    // console.log('window removed: id=' + windowId);
  });

  chrome.browserAction.onClicked.addListener(function(tab) {
    // console.log('broswerAction clicked');
  });

};

DepthJS.tools.obj_repr = function (obj, className) {
  var buf = [];
  if (className === undefined) {
    buf.push('[Object ');
  } else {
    buf.push('[' + className + ' ');
  }
  for (var key in obj) {
    buf.push(key + '=' + obj[key]);
    buf.push(', ');
  }
  buf.pop();
  buf.push(']');
  return buf.join('');
};

DepthJS.backend.eventsWs = null;
DepthJS.backend.imageWs = null;
DepthJS.backend.depthWs = null;
DepthJS.backend.host = "localhost";
DepthJS.backend.eventsPort = 14444;
DepthJS.backend.imagePort = 14445;
DepthJS.backend.depthPort = 14446;

DepthJS.backend.connect = function() {
  return _.all(_.map(["events", "image", "depth"], function(stream) {
    var port = DepthJS.backend[stream+"Port"];
    console.log("Connecting to " + stream + " stream on " +
      DepthJS.backend.host + ":" + port);
    if (DepthJS.backend[stream+"Ws"] != null) {
      console.log("Already connected or connecting");
      return false;
    }
    var socket = new io.Socket(DepthJS.backend.host, {
      transports: ["websocket"],
      port: port
    });
    socket.connect();
    DepthJS.backend[stream+"Ws"] = socket;

    socket.on('message', function(data){
      DepthJS.backend.onMessage(stream, data);
    });

    socket.on("disconnect", function() {
      DepthJS.backend.onDisconnect(stream);
    });

    socket.on("connect", function() {
      DepthJS.backend.onConnect(stream);
    });

    return true;
  }));
};

DepthJS.backend.onMessage = function (stream, data) {
  if (stream == "events") {
    if (data === undefined || data.data == null) {
      return;
    }

    var msg = JSON.parse(data.data);
    if (!$.isPlainObject(msg)) {
      console.log('Unknown message: ' + data);
      return;
    }
    var handler = DepthJS.eventHandlers["on"+msg.type];
    if (handler != null) {
      handler(msg.data);
    }

    msg.jsonRep = data.data;
    // Don't send to all--send to only the current tab.
    // _.each(DepthJS.eventListeners, function(port) {
    //   port.postMessage(msg);
    // });
    chrome.tabs.getSelected(null, function (tab) {
      var tabPorts = DepthJS.portsByTabId[tabId];
      if (tabPorts == null) {
        console.log("Could not find ports for tabId " + tabId);
        return;
      }
      var eventPort = tabPorts.event;
      if (eventPort == null) {
        console.log("Could not find event port for tabId " + tabId);
        return;
      }

      eventPort.postMessage(msg);
    });
  } else if (stream == "image") {
    DepthJS.eventHandlers.onImageMsg(data);
  } else if (stream == "depth") {
    DepthJS.eventHandlers.onDepthMsg(data);
  }
};

DepthJS.backend.onDisconnect = function (stream) {
  console.log("Disconnected on " + stream + " stream");
};


DepthJS.eventHandlers.onNewTab = function(url, title, windowId, tabId) {
  test();
};

DepthJS.eventHandlers.onClosedTab = function(url, windowId, tabId) {
  if (DepthJS.portsByTabId[tabId] != null) {
    console.log("Had ports by closed tab laying around, deleting");
    delete DepthJS.portsByTabId[tabId];
  }
};

DepthJS.eventHandlers.onReaccessedTab = function(url, windowId, tabId) {
  test();
};

(function() {
  // WebSockets have frames of a limited size (<32k seems to work best)
  // Buffer the data until we have a complete frame
  function makeImageBuffer(listeners, bytes) {
    var w = 640;
    var h = 480;
    var data = [];

    return function(frameData) {
      if (data.length + frameData.length < w*h*bytes) {
        data.concat(frameData);
      } else {
        var rem = (data.length + frameData.length) - w*h*bytes;
        var remData = frameData.splice(frameData.length - rem - 1);
        if (remData.length > 0) data.concat(remData);
        _.each(listeners, function(port) {
            port.postMessage({data: data});
        });
        data = remData;
      }
    };
  }
  DepthJS.eventHandlers.onDepthMsg = makeImageBuffer(DepthJS.depthListeners, 1);
  DepthJS.eventHandlers.onImageMsg = makeImageBuffer(DepthJS.imageListeners, 3);
})();

console.log('Defined DepthJS... launching init');
DepthJS.init();

console.log("Setting up message passing listener");
var urls = [];
chrome.extension.onConnect.addListener(function(port) {
  var name = port.name;
  console.assert(name == "event" || name == "image" || name == "depth");
  console.log(name + " port connected");
  var listeners =  DepthJS[name + "Listeners"];
  listeners.push(port);

  var tabId = port.sender.tab.id;
  var tabPorts = DepthJS.portsByTabId[tabId];
  if (tabPorts == null) {
    tabPorts = {}; DepthJS.portsByTabId[tabId] = tabPorts;
  }
  tabPorts[name] = port;


  if (name == "event") {
    port.onMessage.addListener(function (req) {
      if (req.type == "getThumbnailUrls") {
        chrome.windows.getAll({populate: true}, function(windows) {
          var finishedWindows = 0;
          urls = [];
          _.each(windows, function(window) {
            console.log("Capturing windowId" + window.id);
            chrome.tabs.captureVisibleTab(window.id, null, function(dataUrl) {
              if (dataUrl !== undefined && dataUrl != null) {
                window.dataUrl = dataUrl;
                //urls.push(split(dataUrl, 12)[0]);
                urls.push(dataUrl.slice(0));
              } else {
                console.log("Ignoring window " + window.id + " without dataUrl");
                // Because windows is closured in this function
                for (var i = 0; i < windows.length; ++i) {
                  if (windows[i].id == window.id) {
                    windows.splice(i, 1);
                    break;
                  }
                }
              }
              finishedWindows++;
              if (finishedWindows == windows.length) {
                console.log(["All thumbnails taken", windows, urls]);
                console.log(urls[0]);
                port.postMessage({type: "ThumbnailUrls", data:{x: urls[0], windows:windows}});
              }
            });
          });
        });
      }
    });
  }


  port.onDisconnect.addListener(function (e) {
    console.log(name + " port disconnected on tab " + tabId);
    DepthJS[name + "Listeners"] = _.reject(
      listeners, function(el) { el === port; });
    var _tabPorts = DepthJS.portsByTabId[tabId];
    if (_tabPorts) {
      delete _tabPorts[name];
      if (_.isEmpty(_tabPorts)) {
        console.log("for all ports on this tab");
        delete DepthJS.portsByTabId[tabId];
      }
    }
  });
});

function split(str, size) {
  var splits = [];
  var lastEnd = 0;
  while (true) {
    if (lastEnd + size > str.length) {
      if (lastEnd != str.length) splits.push(str.slice(lastEnd));
      break;
    } else {
      splits.push(str.slice(lastEnd, lastEnd+size));
      lastEnd += size;
    }
  }
  return splits;
}

chrome.extension.onRequest.addListener(function(req, sender, sendResponse) {
  console.log(sender.tab ?
              "from a content script:" + sender.tab.url :
              "from the extension");
});


function sendTestEvent(msg, callback) {
  console.log("Sending out test event " + msg.type);
  msg.jsonRep = JSON.stringify(msg);

  chrome.tabs.getSelected(null, function (tab) {
    console.assert(msg.type != undefined);
    var tabId = tab.id;
    var tabPorts = DepthJS.portsByTabId[tabId];
    if (tabPorts == null) {
      console.log("Could not find ports for tabId " + tabId);
      return;
    }
    var eventPort = tabPorts.event;
    if (eventPort == null) {
      console.log("Could not find event port for tabId " + tabId);
      return;
    }
    console.log([msg, " send to ", eventPort]);
    eventPort.postMessage(msg);
    callback();
  });
}

function makeTestEvents() {
  // Depthose test
  return [
    {type:"Register", data:{}},
    {type:"Pull", data:{}},
    {type:"Move", data:{x: 15, y: 15}},
    {type:"Unregister", data:{}},
    {type:"Register", data:{}},
    {type:"Pull", data:{}},
    {type:"Move", data:{x: -15, y: 15}},
    {type:"Move", data:{x: 40, y: 80}},
    {type:"Push", data:{}}
  ].reverse();

  // Selector box & nav test
  return [
    {type: "TestEvent", data: {x:0, y:0}},
    {type: "SwipeDown", data: {}},
    {type: "SwipeUp", data: {}},
    {type: "SwipeRight", data: {}},
    {type: "SwipeLeft", data: {}},
    {type:"Register", data:{}},
    {type:"Unregister", data:{}},
    {type:"Register", data:{}},
    {type:"Move", data:{x: 15, y: 15}},
    {type:"Move", data:{x: -15, y: 15}},
    {type:"Move", data:{x: 40, y: 80}},
    {type:"Push", data:{}},
    {type:"Pull", data:{}}
  ].reverse();
}

var currentTest = [];

function test() {
  console.log("Starting new test sequence");
  // Cancel all other ones
  for (var i = 0; i < 20; i++) { currentTest.pop(); }
  // Make new test with closure
  var local = currentTest = makeTestEvents();
  function next() {
    var event = local.pop();
    if (event != undefined) {
      sendTestEvent(event, function() {
        setTimeout(next, 3000);
      });
    }
  }
  next();
}

</script>
</head></html>
